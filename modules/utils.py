import streamlit as st
import pandas as pd
import numpy as np
import base64
from io import BytesIO
import plotly.graph_objects as go
import matplotlib.pyplot as plt
import os
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# --- Helper Functions for Explanations ---

def get_general_explanation(chart_type, **kwargs):
    """Генерирует общее пояснение для графика или таблицы."""
    if chart_type == "bar_years":
        return """
        **Как читать этот график:**
        *   **Ось X (Год):** Показывает годы, за которые доступны данные.
        *   **Ось Y (Количество наблюдений):** Показывает общее количество наблюдений (событий) в каждом году.
        *   **Высота столбцов:** Чем выше столбец, тем больше наблюдений было в соответствующем году.
        *   **Тенденции:** Обратите внимание на общую тенденцию - растет, падает или остается стабильным количество наблюдений со временем. Это может указывать на рост или снижение активности.
        """
    elif chart_type == "pie_currency":
        return """
        **Как читать эту диаграмму:**
        *   **Секторы:** Каждый сектор представляет одну валюту, в которой происходили события.
        *   **Размер сектора:** Размер сектора пропорционален доле записей (событий) в данной валюте от общего числа записей.
        *   **Проценты:** Указанные проценты показывают относительную долю каждой валюты.
        *   **Интерпретация:** Преобладание одной валюты (например, RUB) является ожидаемым для большинства российских компаний. Наличие других валют может указывать на операции в иностранной валюте.
        """
    elif chart_type == "hist_price":
        return """
        **Как читать эту гистограмму:**
        *   **Ось X (Целевое значение (норм.)):** Показывает диапазоны значений целевой колонки.
        *   **Ось Y (Частота):** Показывает, сколько раз значения попадали в каждый диапазон.
        *   **Форма распределения:** Высокие столбцы указывают на наиболее частые диапазоны значений. Форма гистограммы помогает понять, сконцентрированы ли значения вокруг определенного уровня или сильно разбросаны.
        *   **Примечание:** На этом графике могут быть отфильтрованы экстремальные значения (выбросы) для лучшей визуализации основного распределения.
        """
    elif chart_type == "table_price_stats":
        return """
        **Как читать эту таблицу:**
        *   **count:** Общее количество записей, для которых указано значение целевой колонки.
        *   **mean:** Среднее значение по всем записям.
        *   **std (Стандартное отклонение):** Показывает, насколько значения в среднем отклоняются от среднего. Большое значение указывает на высокую вариативность значений.
        *   **min:** Минимальное зафиксированное значение.
        *   **25% (1-й квартиль):** 25% всех значений ниже этого уровня.
        *   **50% (Медиана):** Половина значений ниже этого уровня, половина - выше. Медиана менее чувствительна к выбросам, чем среднее.
        *   **75% (3-й квартиль):** 75% всех значений ниже этого уровня.
        *   **max:** Максимальное зафиксированное значение.
        """
    elif chart_type == "table_missing_values":
        return """
        **Как читать эту таблицу:**
        *   **Колонка:** Название поля в исходных данных.
        *   **Количество пропущенных значений:** Сколько ячеек в этой колонке не содержат данных (пустые).
        *   **Процент пропущенных значений:** Доля пустых ячеек от общего числа записей.
        *   **Важность:** Большое количество пропусков в ключевых полях (целевое значение, дата, ID) может существенно повлиять на качество анализа и прогнозирования.
        """
    elif chart_type == "table_material_counts":
        return """
        **Как читать эту таблицу:**
        *   **ID временного ряда:** Уникальный идентификатор временного ряда.
        *   **Количество записей:** Сколько раз данный временной ряд встречается в данных (например, количество событий).
        *   **Интерпретация:** Временные ряды с большим количеством записей имеют более длинную историю. Временные ряды с малым количеством записей могут быть новыми, редкими или иметь неполную историю.
        """
    elif chart_type == "hist_material_records":
        return """
        **Как читать эту гистограмму:**
        *   **Ось X (Количество записей):** Показывает диапазоны количества записей на один временной ряд (например, 1 запись, 2-5 записей и т.д.).
        *   **Ось Y (Частота):** Показывает, сколько *временных рядов* попадает в каждый диапазон по количеству записей.
        *   **Интерпретация:** График показывает, преобладают ли в данных временные ряды с большим или малым количеством исторических записей. Большое количество рядов с 1-2 записями может затруднить анализ и прогнозирование для этих позиций.
        *   **Примечание:** Ось X может быть ограничена для наглядности (например, до 100 записей).
        """
    elif chart_type == "table_records_stats":
        return """
        **Как читать эту таблицу:**
        *   Эта таблица показывает статистику распределения *количества записей* по всем уникальным временным рядам.
        *   **count:** Общее количество уникальных временных рядов.
        *   **mean:** Среднее количество записей на один временной ряд.
        *   **std:** Стандартное отклонение количества записей. Большое значение говорит о сильном разбросе (есть временные ряды с очень малым и очень большим числом записей).
        *   **min:** Минимальное количество записей для одного временного ряда (часто равно 1).
        *   **25%, 50% (Медиана), 75%:** Показывают, у какого процента временных рядов количество записей ниже указанного значения. Например, медиана (50%) показывает, что у половины рядов записей меньше этого числа, а у половины - больше.
        *   **max:** Максимальное количество записей для одного временного ряда.
        """
    elif chart_type == "bar_material_categories":
        return """
        **Как читать этот график:**
        *   **Ось X (Категория):** Группы временных рядов, разделенные по количеству исторических записей (1, 2-5, 6-10 и т.д.).
        *   **Ось Y (Количество временных рядов):** Сколько уникальных временных рядов попало в каждую категорию.
        *   **Интерпретация:** Позволяет быстро оценить, какая доля временных рядов имеет достаточную историю для анализа (например, >20 записей), а какая - недостаточную. Временные ряды с малым количеством записей часто исключаются из прогнозирования.
        """
    # Добавляем пояснения для графиков из Visualizer
    elif chart_type == "bar_top_materials_records":
        return """
        **Как читать этот график:**
        *   **Ось X (ID Временного ряда):** Показывает 20 временных рядов с наибольшим количеством записей.
        *   **Ось Y (Количество записей):** Высота столбца соответствует количеству записей для данного временного ряда.
        *   **Интерпретация:** Помогает быстро определить временные ряды с самой длинной историей в наборе данных.
        """
    elif chart_type == "bar_top_material_groups":
        return """
        **Как читать этот график:**
        *   **Ось X (Группа):** Показывает 10 групп с наибольшим количеством *уникальных* временных рядов внутри группы.
        *   **Ось Y (Количество уникальных временных рядов):** Высота столбца соответствует количеству уникальных временных рядов в данной группе.
        *   **Интерпретация:** Помогает понять, какие категории временных рядов наиболее разнообразны.
        """
    elif chart_type == "pie_material_records_categories":
        return """
        **Как читать эту диаграмму:**
        *   **Секторы:** Представляют категории временных рядов, сгруппированные по количеству записей (1, 2-5, 6-10 и т.д.).
        *   **Размер сектора:** Пропорционален доле временных рядов, попадающих в данную категорию, от общего числа уникальных рядов.
        *   **Интерпретация:** Визуализирует ту же информацию, что и столбчатая диаграмма "Распределение временных рядов по категориям количества записей", но в виде долей от общего числа.
        """
    elif chart_type == "line_monthly_records":
        return """
        **Как читать этот график:**
        *   **Ось X (Дата):** Временная шкала по месяцам.
        *   **Ось Y (Количество данных):** Общее количество данных (по всем временным рядам) в каждом месяце.
        *   **Интерпретация:** Показывает общую динамику активности по месяцам. Позволяет выявить сезонность, периоды роста или спада.
        """
    elif chart_type == "heatmap_monthly_yearly_records":
        return """
        **Как читать эту тепловую карту:**
        *   **Ось X (Месяц):** Месяцы года.
        *   **Ось Y (Год):** Годы, за которые есть данные.
        *   **Цвет ячейки:** Показывает общее количество данных (по всем временным рядам) в конкретный месяц конкретного года. Цветовая шкала показывает соответствие цвета и количества.
        *   **Интерпретация:** Позволяет визуально оценить:
            *   **Годовой тренд:** Изменение цвета по вертикали.
            *   **Сезонность активности:** Повторяющиеся цветовые паттерны по горизонтали.
            *   **Аномально активные/неактивные периоды:** Резко выделяющиеся по цвету ячейки.
        """
    elif chart_type == "line_monthly_avg_price":
        return """
        **Как читать этот график:**
        *   **Ось X (Месяц):** Месяцы года.
        *   **Ось Y (Среднее значение (норм.)):** Среднее значение целевой колонки по *всем* записям в данном месяце за все годы.
        *   **Цвет линии:** Каждая линия представляет отдельный год.
        *   **Интерпретация:** Показывает сезонные колебания средних значений по всем временным рядам. Сравнение линий разных лет позволяет увидеть общие тренды изменения значений.
        """
    elif chart_type == "bar_top_volatile":
        return """
        **Как читать этот график:**
        *   **Ось X (ID Временного ряда):** Показывает 20 временных рядов с самым высоким коэффициентом вариации (CV).
        *   **Ось Y (Коэффициент вариации):** Показывает значение CV в процентах. CV - это отношение стандартного отклонения к среднему значению.
        *   **Интерпретация:** Высокий CV (например, > 30-50%) указывает на значительную нестабильность или разброс значений для данного временного ряда. Это могут быть ряды с ошибками в данных или с объективно высокой волатильностью.
        """
    elif chart_type == "bar_bottom_volatile":
        return """
        **Как читать этот график:**
        *   **Ось X (ID Временного ряда):** Показывает 20 временных рядов с самым низким *ненулевым* коэффициентом вариации (CV).
        *   **Ось Y (Коэффициент вариации):** Показывает значение CV в процентах.
        *   **Интерпретация:** Низкий CV (например, < 5-10%) указывает на высокую стабильность значений для данного временного ряда. Ряды с нулевым CV (абсолютно одинаковое значение) сюда не включаются.
        """
    elif chart_type == "hist_cv_distribution":
        return """
        **Как читать эту гистограмму:**
        *   **Ось X (Коэффициент вариации):** Диапазоны значений CV в процентах.
        *   **Ось Y (Частота):** Сколько временных рядов попало в каждый диапазон CV.
        *   **Интерпретация:** Показывает общее распределение стабильности значений по всем временным рядам. Преобладание столбцов слева (низкий CV) говорит о большом количестве стабильных рядов, справа - о преобладании волатильных.
        *   **Примечание:** Ось X может быть ограничена (например, до 100%) для наглядности.
        """
    elif chart_type == "pie_cv_categories":
        return """
        **Как читать эту диаграмму:**
        *   **Секторы:** Представляют категории временных рядов, сгруппированные по уровню волатильности (0-5%, 5-10% и т.д.).
        *   **Размер сектора:** Пропорционален доле временных рядов, попадающих в данную категорию волатильности.
        *   **Интерпретация:** Позволяет быстро оценить, какая доля временных рядов имеет низкую, среднюю или высокую волатильность.
        """
    elif chart_type == "pie_stability_distribution":
        return """
        **Как читать эту диаграмму:**
        *   **Секторы:** Делят временные ряды на две группы: со "стабильным" значением (например, >=80% одинаковых значений) и "нестабильным" (<80%).
        *   **Размер сектора:** Показывает долю временных рядов в каждой группе.
        *   **Интерпретация:** Дает общую оценку количества временных рядов с очень устойчивыми значениями в наборе данных.
        """
    elif chart_type == "bar_top_stable_percentage":
        return """
        **Как читать этот график:**
        *   **Ось X (ID Временного ряда):** Показывает 20 временных рядов (с >1 записью) с наивысшим процентом одинаковых значений в их истории.
        *   **Ось Y (Процент одинаковых значений):** Показывает долю записей с самым частым значением для данного временного ряда.
        *   **Интерпретация:** Выделяет временные ряды, значения которых практически не менялись. Значение 100% означает, что все записи имели одно и то же значение.
        """
    elif chart_type == "scatter_records_vs_stability":
        return """
        **Как читать этот график:**
        *   **Ось X (Количество записей):** Сколько записей у временного ряда (ограничено для наглядности, например, до 100).
        *   **Ось Y (Процент одинаковых значений):** Насколько стабильно значение для ряда (100% = абсолютно стабильно).
        *   **Каждая точка:** Представляет один временной ряд.
        *   **Цвет точки:** Разделяет ряды на "Стабильные" (выше порога, например, 80%, красная линия) и "Нестабильные" (ниже порога).
        *   **Интерпретация:** Позволяет увидеть, есть ли связь между количеством записей и стабильностью. Например, часто ли ряды с малым числом записей имеют стабильное значение, и наоборот.
        """
    elif chart_type == "bar_inactivity_categories":
        return """
        **Как читать этот график:**
        *   **Ось X (Категория неактивности):** Периоды времени, прошедшие с последнего события (<30 дней, 30-90 дней и т.д.).
        *   **Ось Y (Количество временных рядов):** Сколько временных рядов попадает в каждую категорию по времени последней активности.
        *   **Интерпретация:** Показывает, сколько временных рядов являются "старыми" (давно не было событий), а сколько - "свежими". Большое количество рядов в правых категориях (>180 дней, >1 года) может указывать на необходимость анализа причин отсутствия событий.
        """
    elif chart_type == "pie_activity_status":
        return """
        **Как читать эту диаграмму:**
        *   **Секторы:** Делят временные ряды на "Активные" (события были в течение последнего года) и "Неактивные" (событий не было больше года).
        *   **Размер сектора:** Показывает долю активных и неактивных временных рядов в общем количестве.
        *   **Интерпретация:** Быстрая оценка доли временных рядов, по которым давно не было движений.
        """
    elif chart_type == "bar_top_inactive":
        return """
        **Как читать этот график:**
        *   **Ось X (ID Временного ряда):** Показывает 20 временных рядов с самым долгим периодом отсутствия событий.
        *   **Ось Y (Дней с последней активности):** Сколько дней прошло с момента последней записи по данному временному ряду.
        *   **Интерпретация:** Выделяет самые "забытые" временные ряды в базе данных.
        """
    elif chart_type == "bar_last_activity_distribution":
        return """
        **Как читать этот график:**
        *   **Ось X (Дата):** Временная шкала по месяцам.
        *   **Ось Y (Количество временных рядов):** Сколько временных рядов имели свою *последнюю* активность (событие) в данном месяце.
        *   **Интерпретация:** Помогает увидеть, были ли периоды, когда большое количество временных рядов перестало быть активными. Например, пик в определенном месяце может указывать на какие-либо системные изменения.
        """
    # Добавляем пояснения для таблиц из MaterialSegmenter
    elif chart_type == "table_volatility":
        return """
        **Как читать эту таблицу:**
        *   **ID Временного ряда:** Уникальный идентификатор временного ряда.
        *   **Количество записей:** Сколько всего записей для этого ряда.
        *   **Среднее значение:** Среднее значение целевой колонки за весь период.
        *   **Стандартное отклонение:** Абсолютная мера разброса значений вокруг среднего.
        *   **Коэффициент вариации (CV):** (Ст. откл. / Среднее значение) * 100%. Относительная мера волатильности. Чем выше CV, тем более изменчиво значение.
        *   **Интерпретация:** Таблица отсортирована по убыванию CV. Вверху - самые волатильные временные ряды, внизу - самые стабильные.
        """
    elif chart_type == "table_stability":
        return """
        **Как читать эту таблицу:**
        *   **ID Временного ряда:** Уникальный идентификатор временного ряда.
        *   **Количество записей:** Сколько всего записей для этого ряда.
        *   **Процент одинаковых значений:** Какая доля (%) от всех записей по этому ряду имеет самое часто встречающееся значение.
        *   **Стабильное значение:** Флаг (True/False), указывающий, превышает ли 'Процент одинаковых значений' установленный порог (например, 80%).
        *   **Интерпретация:** Таблица отсортирована по убыванию 'Процента одинаковых значений'. Вверху - временные ряды с наиболее стабильным/фиксированным значением.
        """
    elif chart_type == "table_inactivity":
        threshold = kwargs.get('threshold', 365) # Получаем порог из аргументов
        return f"""
        **Как читать эту таблицу:**
        *   **ID Временного ряда:** Уникальный идентификатор временного ряда.
        *   **Последняя активность:** Дата последней записи (события) для этого ряда.
        *   **Дней с последней активности:** Сколько дней прошло с последней активности до самой поздней даты во всем наборе данных.
        *   **Неактивный временной ряд:** Флаг (True/False), указывающий, превышает ли 'Дней с последней активности' установленный порог неактивности ({threshold} дней).
        *   **Интерпретация:** Таблица отсортирована по убыванию 'Дней с последней активности'. Вверху - временные ряды, которые не были активны дольше всего.
        """
    else:
        return ""

def get_material_specific_explanation(chart_type, material_name):
    """Генерирует пояснение для графика или таблицы по конкретному временному ряду."""
    if chart_type == "bar_years_material":
        return f"""
        **Как читать этот график для временного ряда '{material_name}':**
        *   **Ось X (Год):** Годы, в которые были записи по данному временному ряду.
        *   **Ось Y (Количество записей):** Количество записей временного ряда '{material_name}' в каждом году.
        *   **Интерпретация:** График показывает динамику событий по конкретному временному ряду по годам. Увеличение столбцов может говорить о росте активности, снижение - об уменьшении. Отсутствие столбцов в некоторые годы указывает на перерывы в наблюдениях.
        """
    elif chart_type == "line_price_time":
        return f"""
        **Как читать этот график для временного ряда '{material_name}':**
        *   **Ось X (Дата):** Временная шкала записей по данному ряду.
        *   **Ось Y (Целевое значение (норм.)):** Значение целевой колонки в соответствующую дату.
        *   **Линия и точки:** Показывают изменение значения для ряда '{material_name}' со временем.
        *   **Интерпретация:**
            *   **Восходящий тренд:** Указывает на рост значения.
            *   **Нисходящий тренд:** Указывает на снижение значения.
            *   **Горизонтальная линия:** Стабильное значение.
            *   **Резкие скачки/падения:** Высокая волатильность, требующая внимания. Могут быть вызваны рыночными факторами, ошибками данных или другими причинами.
            *   **Большие промежутки между точками:** Редкие события.
        """
    elif chart_type == "line_monthly_seasonality":
        return f"""
        **Как читать этот график для временного ряда '{material_name}':**
        *   **Ось X (Месяц):** Месяцы года.
        *   **Ось Y (Целевое значение (норм.)):** Среднее значение для ряда '{material_name}' за все годы в соответствующем месяце.
        *   **Интерпретация:** График помогает выявить сезонные колебания.
            *   **Пики:** Месяцы с традиционно высокими значениями.
            *   **Спады:** Месяцы с традиционно низкими значениями.
            *   **Отсутствие явных пиков/спадов:** Значение слабо зависит от времени года или сезонность не выражена в имеющихся данных.
        *   **Важно:** Для достоверных выводов о сезонности нужна достаточно длинная история данных (несколько лет).
        """
    elif chart_type == "heatmap_monthly_yearly":
        return f"""
        **Как читать эту тепловую карту для временного ряда '{material_name}':**
        *   **Ось X (Месяц):** Месяцы года.
        *   **Ось Y (Год):** Годы, за которые есть данные.
        *   **Цвет ячейки:** Показывает среднее значение для ряда '{material_name}' в конкретный месяц конкретного года. Цветовая шкала (обычно справа) показывает соответствие цвета и уровня значения (например, от синего/холодного - низкое значение, до желтого/красного/теплого - высокое значение).
        *   **Интерпретация:** Позволяет визуально оценить:
            *   **Общий тренд:** Изменение цвета по вертикали (снизу вверх).
            *   **Сезонность:** Повторяющиеся цветовые паттерны по горизонтали (внутри одного года).
            *   **Аномалии:** Резко выделяющиеся по цвету ячейки.
        *   **Пропуски (белые/серые ячейки):** Отсутствие данных за данный месяц/год.
        """
    elif chart_type == "table_interval_stats":
        return f"""
        **Как читать эту таблицу для временного ряда '{material_name}':**
        *   Эта таблица показывает статистику по времени (в днях), проходящему *между* последовательными записями (событиями) для ряда '{material_name}'.
        *   **count:** Общее количество рассчитанных интервалов (на 1 меньше, чем записей).
        *   **mean:** Среднее время между событиями.
        *   **std:** Стандартное отклонение времени между событиями. Большое значение указывает на нерегулярность.
        *   **min:** Минимальный зафиксированный интервал между событиями (например, 0 или 1 день).
        *   **25%, 50% (Медиана), 75%:** Показывают распределение интервалов. Медиана - типичное время между событиями.
        *   **max:** Максимальный зафиксированный перерыв между событиями.
        *   **Интерпретация:** Помогает понять регулярность событий для временного ряда. Короткие интервалы - частые события, длинные - редкие.
        """
    elif chart_type == "hist_interval_distribution":
        return f"""
        **Как читать эту гистограмму для временного ряда '{material_name}':**
        *   **Ось X (Интервал, дни):** Диапазоны времени (в днях) между последовательными записями.
        *   **Ось Y (Частота):** Сколько раз встречался интервал, попадающий в данный диапазон.
        *   **Интерпретация:** Показывает наиболее характерные периоды между событиями для ряда '{material_name}'.
            *   **Высокий столбец слева:** Частые события с небольшими интервалами.
            *   **Высокий столбец справа:** Редкие события с большими перерывами.
            *   **Несколько пиков:** Возможны разные режимы (например, регулярные мелкие и редкие крупные события).
        """
    else:
        return ""

# --- End Helper Functions ---

def apply_custom_css():
    """
    Применяет пользовательские CSS-стили из файла static/styles.css к приложению Streamlit.
    """
    # Определяем путь к файлу CSS относительно текущего файла
    css_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), 'static', 'styles.css')

    # Проверяем наличие файла CSS
    if os.path.exists(css_path):
        try:
            with open(css_path, 'r', encoding='utf-8') as f:
                css = f.read()
            st.markdown(f'<style>{css}</style>', unsafe_allow_html=True)
            logger.info("Custom CSS applied successfully from %s", css_path)
        except Exception as e:
            logger.error("Error reading or applying CSS file %s: %s", css_path, e)
            st.error(f"Не удалось загрузить стили оформления: {e}")
    else:
        # Если файл не найден, выводим предупреждение
        logger.warning("CSS file not found at %s. Using default Streamlit styles.", css_path)
        st.warning("Файл стилей styles.css не найден. Используются стандартные стили.")

def format_number(number, precision=2):
    """
    Форматирует число с разделителями тысяч и указанной точностью.
    Обрабатывает NaN и бесконечные значения.
    """
    # Проверяем на NaN и бесконечность с помощью numpy
    if not np.isfinite(number):
        # Для NaN возвращаем прочерк, для inf оставляем как есть
        return "-" if pd.isna(number) else str(number)

    if isinstance(number, (int, float, np.number)): # Добавляем np.number для совместимости
        try:
            # Проверяем, является ли число целым
            # Используем np.isclose для сравнения float с int
            if np.isclose(number, round(number)):
                # Форматируем как целое
                return f"{int(round(number)):,}".replace(",", " ")
            else:
                # Форматируем как float с указанной точностью
                return f"{number:,.{precision}f}".replace(",", " ").replace(".", ",")
        except (ValueError, OverflowError):
            # В случае ошибки форматируем как строку
            return str(number)

    # Возвращаем как строку, если это не число
    return str(number)

def get_download_link(df, filename, text):
    """
    Создает ссылку для скачивания DataFrame в формате Excel
    """
    output = BytesIO()
    writer = pd.ExcelWriter(output, engine='xlsxwriter')
    # Попытка вернуть исходные имена колонок перед экспортом, если задан mapping
    export_df = df.copy()
    try:
        import streamlit as st
        if 'column_mapping' in st.session_state and st.session_state.get('column_mapping'):
            mapping = st.session_state['column_mapping'] or {}
            rename_map = {}
            for canonical_role, original_col in mapping.items():
                if not original_col:
                    continue
                if canonical_role in export_df.columns:
                    rename_map[canonical_role] = original_col
                canonical_norm = f"{canonical_role} (норм.)"
                if canonical_norm in export_df.columns:
                    rename_map[canonical_norm] = f"{original_col} (норм.)"
            if rename_map:
                export_df = export_df.rename(columns=rename_map)
    except Exception:
        pass

    export_df.to_excel(writer, sheet_name='Данные', index=False)
    
    # Автоподбор ширины столбцов
    workbook = writer.book
    worksheet = writer.sheets['Данные']
    
    for i, col in enumerate(df.columns):
        column_width = max(df[col].astype(str).map(len).max(), len(col)) + 2
        worksheet.set_column(i, i, column_width)
    
    writer.close()
    
    b64 = base64.b64encode(output.getvalue()).decode()
    return f'<a href="data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,{b64}" download="{filename}">{text}</a>'

def create_heatmap(pivot_data, title):
    """
    Создает тепловую карту из сводной таблицы
    """
    fig = go.Figure(data=go.Heatmap(
        z=pivot_data.values,
        x=pivot_data.columns,
        y=pivot_data.index,
        colorscale="Viridis",
        colorbar=dict(title="Значение"),
        hoverongaps=False
    ))
    
    fig.update_layout(
        title=title,
        height=500,
        yaxis_title="Строки",
        xaxis_title="Столбцы"
    )
    
    return fig

def create_correlation_matrix(df, columns, title="Корреляционная матрица"):
    """
    Создает корреляционную матрицу для выбранных столбцов
    """
    # Выбираем только числовые столбцы из списка
    numeric_columns = [col for col in columns if pd.api.types.is_numeric_dtype(df[col])]
    
    if not numeric_columns:
        return None
    
    # Вычисляем корреляцию
    corr_matrix = df[numeric_columns].corr()
    
    # Создаем тепловую карту
    fig = go.Figure(data=go.Heatmap(
        z=corr_matrix.values,
        x=corr_matrix.columns,
        y=corr_matrix.index,
        colorscale="RdBu_r",
        zmid=0,  # Центр шкалы в 0
        colorbar=dict(title="Корреляция"),
        hoverongaps=False
    ))
    
    fig.update_layout(
        title=title,
        height=600,
        width=700,
        yaxis_title="",
        xaxis_title=""
    )
    
    return fig

def plot_time_series_decomposition(series, title="Декомпозиция временного ряда"):
    """
    Создает график декомпозиции временного ряда на тренд, сезонность и остаток
    """
    from statsmodels.tsa.seasonal import seasonal_decompose
    
    # Проверяем, что временной ряд достаточной длины для декомпозиции
    if len(series) < 4:
        return None
    
    # Выполняем декомпозицию
    try:
        # Определяем период сезонности
        freq = series.index.freq
        period = 12  # По умолчанию для месячных данных
        
        if freq == 'D':
            period = 7  # Для дневных данных (неделя)
        elif freq == 'W':
            period = 52  # Для недельных данных (год)
        elif freq == 'Q':
            period = 4  # Для квартальных данных
        
        # Выполняем декомпозицию
        decomposition = seasonal_decompose(
            series, 
            model='additive', 
            period=min(period, len(series) // 2)  # Не более половины длины ряда
        )
        
        # Создаем фигуру с подграфиками
        fig, axes = plt.subplots(4, 1, figsize=(10, 12))
        
        # Исходный ряд
        decomposition.observed.plot(ax=axes[0])
        axes[0].set_title('Исходный ряд')
        axes[0].set_xlabel('')
        
        # Тренд
        decomposition.trend.plot(ax=axes[1])
        axes[1].set_title('Тренд')
        axes[1].set_xlabel('')
        
        # Сезонность
        decomposition.seasonal.plot(ax=axes[2])
        axes[2].set_title('Сезонность')
        axes[2].set_xlabel('')
        
        # Остаток
        decomposition.resid.plot(ax=axes[3])
        axes[3].set_title('Остаток')
        
        plt.tight_layout()
        
        return fig
    
    except Exception as e:
        st.error(f"Ошибка при декомпозиции временного ряда: {str(e)}")
        return None

def calculate_min_forecast_points(freq, horizon):
    """
    Вычисляет минимальное количество точек данных для прогнозирования
    на основе частоты и горизонта прогнозирования
    """
    # Минимальное количество точек для разных частот
    min_points = {
        'D': max(14, horizon),       # Для дневных данных
        'W': max(8, horizon),        # Для недельных данных
        'M': max(6, horizon),        # Для месячных данных
        'Q': max(4, horizon),        # Для квартальных данных
        'Y': max(3, horizon)         # Для годовых данных
    }
    
    # Возвращаем минимальное количество точек или 2*horizon, если частота не указана
    return min_points.get(freq, max(5, 2 * horizon))

def detect_outliers(series, method='iqr', threshold=1.5):
    """
    Обнаруживает выбросы во временном ряду
    
    Args:
        series: pandas Series с данными
        method: метод обнаружения выбросов ('iqr' или 'zscore')
        threshold: порог для определения выбросов
    
    Returns:
        pandas Series с булевыми значениями (True для выбросов)
    """
    if method == 'iqr':
        # Метод межквартильного размаха
        q1 = series.quantile(0.25)
        q3 = series.quantile(0.75)
        iqr = q3 - q1
        lower_bound = q1 - threshold * iqr
        upper_bound = q3 + threshold * iqr
        
        return (series < lower_bound) | (series > upper_bound)
    
    elif method == 'zscore':
        # Метод z-оценки
        mean = series.mean()
        std = series.std()
        
        if std == 0:  # Предотвращаем деление на ноль
            return pd.Series(False, index=series.index)
        
        z_scores = (series - mean) / std
        
        return abs(z_scores) > threshold
    
    else:
        # Если метод не распознан, возвращаем все False
        return pd.Series(False, index=series.index)

def format_streamlit_dataframe(df, height=None):
    """
    Форматирует DataFrame для отображения в Streamlit
    
    Args:
        df: pandas DataFrame
        height: высота таблицы в пикселях (None - автоматически)
        
    Returns:
        стилизованный DataFrame
    """
    # Применяем базовый стиль к таблице
    styled_df = df.style.set_table_styles([
        {'selector': 'th', 'props': [('background-color', '#E3F2FD'), 
                                     ('color', '#000000'), 
                                     ('font-weight', 'bold'),
                                     ('border', '1px solid #B0BEC5')]},
        {'selector': 'td', 'props': [('border', '1px solid #E0E0E0')]},
        {'selector': 'tr:hover', 'props': [('background-color', '#F5F5F5')]},
        {'selector': 'tr:nth-child(even)', 'props': [('background-color', '#FAFAFA')]}
    ])
    
    # Форматируем числовые столбцы
    numeric_cols = df.select_dtypes(include=['float', 'int']).columns
    for col in numeric_cols:
        if 'процент' in col.lower() or 'доля' in col.lower() or '%' in col:
            # Форматируем как процент с двумя десятичными знаками
            styled_df = styled_df.format({col: lambda x: f"{x:.2f}%"})
        elif 'цена' in col.lower() or 'стоимость' in col.lower() or 'руб' in col.lower():
            # Используем функцию format_number для форматирования чисел с разделителями тысяч
            styled_df = styled_df.format({col: lambda x: format_number(x, precision=2)})
        elif df[col].dtype == 'int64':
            # Целые числа форматируем с разделителями тысяч
            styled_df = styled_df.format({col: lambda x: format_number(x, precision=0)})
        else:
            # Прочие числа форматируем с двумя десятичными знаками
            styled_df = styled_df.format({col: lambda x: format_number(x, precision=2)})
    
    # Опционально можно выделить цветом ячейки на основе значений
    # Например, выделить отрицательные значения красным
    def highlight_negative(val):
        if isinstance(val, (int, float)) and val < 0:
            return 'color: red'
        return ''
    
    # Use Styler.map (replacement for deprecated applymap) to apply per-cell styles
    try:
        styled_df = styled_df.map(highlight_negative)
    except Exception:
        # Fallback to applymap if map not available in older pandas versions
        styled_df = styled_df.applymap(highlight_negative)
    
    return styled_df

def show_error_message(error, error_type="Ошибка", show_traceback=False):
    """
    Отображает сообщение об ошибке в приятном для пользователя формате
    
    Args:
        error: объект исключения или текст ошибки
        error_type: тип ошибки (например, "Ошибка загрузки данных")
        show_traceback: показывать ли трассировку стека
    """
    import traceback
    
    # Главное сообщение об ошибке
    error_html = f"""
    <div style="background-color: #FFEBEE; padding: 15px; border-radius: 5px; margin: 10px 0;">
        <h3 style="color: #B71C1C; margin-top: 0;">{error_type}</h3>
        <p style="margin-bottom: 5px; font-size: 16px;">{str(error)}</p>
    """
    
    # Добавляем советы по решению типичных проблем
    if "encoding" in str(error).lower() or "encod" in str(error).lower():
        error_html += """
        <div style="background-color: #FFF3E0; padding: 10px; border-radius: 3px; margin-top: 10px;">
            <p style="margin: 0; font-weight: bold;">Возможные решения:</p>
            <ul style="margin-top: 5px;">
                <li>Проверьте кодировку файла (UTF-8, Windows-1251)</li>
                <li>Исключите из файла нестандартные символы</li>
                <li>Убедитесь, что файл не поврежден</li>
            </ul>
        </div>
        """
    elif "memory" in str(error).lower() or "memory" in str(error).lower():
        error_html += """
        <div style="background-color: #FFF3E0; padding: 10px; border-radius: 3px; margin-top: 10px;">
            <p style="margin: 0; font-weight: bold;">Возможные решения:</p>
            <ul style="margin-top: 5px;">
                <li>Попробуйте загрузить файл меньшего размера</li>
                <li>Увеличьте ограничение памяти в настройках приложения</li>
                <li>Разделите большой файл на несколько меньших</li>
            </ul>
        </div>
        """
    elif "файл" in str(error).lower() or "file" in str(error).lower():
        error_html += """
        <div style="background-color: #FFF3E0; padding: 10px; border-radius: 3px; margin-top: 10px;">
            <p style="margin: 0; font-weight: bold;">Возможные решения:</p>
            <ul style="margin-top: 5px;">
                <li>Проверьте формат и структуру файла</li>
                <li>Убедитесь, что файл содержит все необходимые колонки</li>
                <li>Попробуйте открыть файл в Excel и сохранить в формате CSV</li>
            </ul>
        </div>
        """
    
    # Добавляем трассировку стека, если запрошено
    if show_traceback:
        stack_trace = traceback.format_exc()
        error_html += f"""
        <details>
            <summary style="cursor: pointer; color: #616161; margin-top: 10px;">Показать техническую информацию</summary>
            <pre style="background-color: #F5F5F5; padding: 10px; border-radius: 3px; margin-top: 5px; 
                      white-space: pre-wrap; font-size: 12px; color: #212121;">{stack_trace}</pre>
        </details>
        """
    
    error_html += "</div>"
    
    # Отображаем HTML
    st.markdown(error_html, unsafe_allow_html=True)

def show_loading_spinner(message="Загрузка данных...", key=None):
    """
    Отображает анимированный индикатор загрузки с сообщением
    
    Args:
        message: текст сообщения
        key: уникальный ключ для виджета (если нужно несколько индикаторов)
    
    Returns:
        placeholder: объект-заполнитель для сообщения
    """
    spinner_html = f"""
    <div style="display: flex; align-items: center; margin: 10px 0;">
        <div class="loading-spinner"></div>
        <span style="margin-left: 10px; color: #424242;">{message}</span>
    </div>
    
    <style>
    .loading-spinner {{
        border: 4px solid #f3f3f3;
        border-radius: 50%;
        border-top: 4px solid #1E88E5;
        width: 24px;
        height: 24px;
        animation: spinner-rotation 1s linear infinite;
    }}
    
    @keyframes spinner-rotation {{
        0% {{ transform: rotate(0deg); }}
        100% {{ transform: rotate(360deg); }}
    }}
    </style>
    """
    
    # Avoid assigning a key to the placeholder container itself. Creating
    # widgets or containers with dynamic keys here can conflict with other
    # widget keys and trigger unintended session_state updates / reruns.
    placeholder = st.empty()
    placeholder.markdown(spinner_html, unsafe_allow_html=True)
    return placeholder

def show_export_success(filename, filesize, duration):
    """
    Отображает сообщение об успешном экспорте данных
    
    Args:
        filename: имя файла
        filesize: размер файла в байтах
        duration: продолжительность экспорта в секундах
    """
    # Преобразуем размер в читаемый формат
    size_str = ""
    if filesize < 1024:
        size_str = f"{filesize} байт"
    elif filesize < 1024 * 1024:
        size_str = f"{filesize / 1024:.1f} КБ"
    else:
        size_str = f"{filesize / (1024 * 1024):.1f} МБ"
    
    success_html = f"""
    <div style="background-color: #E8F5E9; padding: 15px; border-radius: 5px; margin: 10px 0;">
        <h3 style="color: #2E7D32; margin-top: 0; margin-bottom: 10px;">Экспорт данных завершен</h3>
        <p style="margin: 0 0 5px 0;"><strong>Файл:</strong> {filename}</p>
        <p style="margin: 0 0 5px 0;"><strong>Размер:</strong> {size_str}</p>
        <p style="margin: 0 0 5px 0;"><strong>Время выполнения:</strong> {duration:.2f} сек.</p>
    </div>
    """
    
    st.markdown(success_html, unsafe_allow_html=True)

def create_styled_dataframe(df, height=None, precision=2, highlight_cols=None, highlight_threshold=None):
    """
    Создает стилизованный DataFrame для отображения в Streamlit
    
    Args:
        df: pandas DataFrame для отображения
        height: высота таблицы в пикселях (None - автоматически)
        precision: точность для числовых значений
        highlight_cols: список колонок для подсветки значений
        highlight_threshold: пороговое значение для подсветки
        
    Returns:
        styled_df: стилизованный DataFrame с форматированием
    """
    # Создаем копию DataFrame для форматирования
    formatted_df = df.copy()
    
    # Функция для форматирования числовых значений
    def format_value(x, precision=precision):
        if pd.isna(x):
            return ""
        elif isinstance(x, (int, np.integer)):
            return f"{x:,}".replace(",", " ")
        elif isinstance(x, (float, np.floating)):
            if x == int(x):  # Если число без десятичной части
                return f"{int(x):,}".replace(",", " ")
            else:
                return f"{x:,.{precision}f}".replace(",", " ")
        else:
            return str(x)
    
    # Применяем форматирование к числовым колонкам
    for col in formatted_df.select_dtypes(include=np.number).columns:
        formatted_df[col] = formatted_df[col].apply(format_value)
    
    # Создаем объект стиля
    styled_df = formatted_df.style
    
    # Добавляем базовое форматирование таблицы
    styled_df = styled_df.set_table_styles([
        {'selector': 'th', 'props': [
            ('background-color', '#E3F2FD'), 
            ('color', '#0D47A1'), 
            ('font-weight', 'bold'),
            ('border', '1px solid #B0BEC5'),
            ('padding', '8px'),
            ('text-align', 'left'),
            ('white-space', 'nowrap'),
            ('overflow', 'hidden'),
            ('text-overflow', 'ellipsis'),
            ('max-width', '200px')
        ]},
        {'selector': 'td', 'props': [
            ('border', '1px solid #E0E0E0'),
            ('padding', '8px'),
            ('max-width', '200px'),
            ('overflow', 'hidden'),
            ('text-overflow', 'ellipsis'),
            ('white-space', 'nowrap')
        ]},
        {'selector': 'tr:hover', 'props': [
            ('background-color', '#E3F2FD')
        ]},
        {'selector': 'tr:nth-child(even)', 'props': [
            ('background-color', '#F5F5F5')
        ]},
        {'selector': 'caption', 'props': [
            ('caption-side', 'bottom'), 
            ('font-style', 'italic'),
            ('color', '#616161'),
            ('padding', '8px'),
            ('text-align', 'left')
        ]},
        # Стиль для всей таблицы
        {'selector': '', 'props': [
            ('border-collapse', 'collapse'),
            ('font-family', 'Arial, sans-serif'),
            ('width', '100%')
        ]}
    ])
    
    # Если указаны колонки для подсветки и порог
    if highlight_cols and highlight_threshold is not None:
        # Преобразуем в список, если передана одна колонка
        if not isinstance(highlight_cols, list):
            highlight_cols = [highlight_cols]
            
        # Подсветка значений выше порога
        for col in highlight_cols:
            if col in df.columns:
                styled_df = styled_df.apply(
                    lambda x: ['background-color: #FFEB9C' if (not pd.isna(y) and float(str(y).replace(' ', '').replace(',', '.')) > highlight_threshold) else '' 
                            for y in x], 
                    subset=[col]
                )
    
    # Добавляем подпись с информацией о размере таблицы
    caption = f"Всего строк: {len(df)}, колонок: {len(df.columns)}"
    styled_df = styled_df.set_caption(caption)
    
    return styled_df

def show_user_guide():
    """
    Отображает руководство пользователя по использованию приложения в формате Markdown
    """
    st.markdown("""
    ## Руководство пользователя

    Это приложение предназначено для анализа данных временных рядов и их целевых колонок, 
    а также для подготовки к прогнозированию значений с помощью различных методов машинного обучения.

    ### Основные разделы

    #### 1. Загрузка данных
    *   В этом разделе вы можете загрузить CSV-файл с данными временных рядов. 
    *   **Обязательные роли колонок:** `ID`, `Дата`, `Целевая Колонка`. Без сопоставления колонок с этими ролями обработка данных не начнется.
    *   **Рекомендуемые роли:** `Количество`, `Валюта`, `Курс`. Эти колонки необходимы для некоторых видов анализа (например, нормализации значений по валюте).
    *   Доступны настройки параметров импорта: кодировка (UTF-8, Windows-1251), разделитель столбцов (например, `;` или `,`), десятичный разделитель (`,` или `.`).
    *   **Пример:** Загрузите файл `data.csv` с кодировкой UTF-8 и разделителем `;`, содержащий колонки, которые вы сможете сопоставить с обязательными ролями.

    *   **Пример структуры данных с рекомендуемыми колонками:**

      | ID_Ряда        | Дата_События | Целевое_Значение | Кол-во | Ед_Изм | Валюта | Курс    | Завод | Документ   | Группа | Категория |
      |-----------------|--------------|------------------|--------|--------|--------|---------|-------|------------|--------|-----------|
      | TS-BOLT-M12     | 01.02.2024   | 55.50            | 1      | ШТ     | RUB    | 1.0000  | 100U  | 4500123456 | N31    | 19010100  |
      | TS-OIL-5L       | 15.03.2024   | 120.00           | 5      | Л      | USD    | 91.5000 | 200P  | 4500123457 | M12    | 25030200  |
      | TS-FABRIC-HB    | 20.03.2024   | 350.75           | 10     | М      | RUB    | 1.0000  | 100U  | 4500123458 | T05    | 31050100  |

    #### 2. Общий анализ
    *   Отображает общую статистику по загруженным и обработанным данным:
        *   Общее количество записей.
        *   Количество уникальных временных рядов.
        *   Временной диапазон данных (самая ранняя и поздняя дата).
        *   Распределение записей по годам.
        *   Статистика по используемым валютам.
        *   Базовая статистика по целевым значениям.
    *   **Пример:** Показывает, что загружено 182067 записей с 01.01.2022 по 31.12.2024, большинство событий в RUB.

    #### 3. Анализ уникальности временных рядов
    *   Анализирует, сколько записей приходится на каждый уникальный временной ряд.
    *   Позволяет выявить:
        *   Временные ряды с наибольшим количеством записей (самые активные).
        *   Временные ряды с одной записью (редкие или разовые события).
        *   Общее распределение: много ли временных рядов с малым числом записей и наоборот.
    *   **Пример:** Временной ряд "TS-BOLT-M12" имеет 500 записей, а "TS-REAGENT-X" - только 1.

    #### 4. Временной анализ
    *   Анализирует динамику целевых значений и событий во времени.
    *   Для выбранного временного ряда можно увидеть:
        *   График изменения целевого значения со временем.
        *   Сезонность (если присутствует).
        *   Статистику по временным интервалам между событиями (как часто они происходят).
    *   **Пример:** Показывает, что целевое значение для "TS-OIL-5L" имеет тенденцию к росту к концу года.

    #### 5. Анализ волатильности
    *   Анализирует изменчивость целевых значений с помощью коэффициента вариации (CV).
    *   Позволяет определить:
        *   Временные ряды с наиболее стабильными значениями (низкий CV).
        *   Временные ряды с наиболее нестабильными значениями (высокий CV).
        *   Общее распределение волатильности по всем временным рядам.
    *   **Пример:** Временной ряд "TS-NAILS" имеет CV=5% (стабильное значение), а "TS-COPPER" - CV=45% (высокая волатильность).

    #### 6. Стабильные временные ряды
    *   Выделяет временные ряды, целевое значение которых почти не меняется.
    *   По умолчанию ищет временные ряды, где 80% или более записей имеют одинаковое значение.
    *   **Пример:** Временной ряд "TS-PAPER-A4" имеет одно и то же значение в 90% событий.

    #### 7. Неактивные временные ряды
    *   Находит временные ряды, по которым давно не было событий.
    *   Можно настроить порог неактивности (например, 365 дней).
    *   **Пример:** Для временного ряда "TS-CARTRIDGE-HP123" не было событий последние 500 дней.

    #### 8. Сегментация для прогнозирования
    *   Разделяет временные ряды на группы (сегменты) на основе их характеристик для выбора наилучшего метода прогнозирования.
    *   **Параметры сегментации:**
        *   `Минимальное количество точек данных:` Сколько записей должно быть у временного ряда для сложного прогноза (по умолчанию 24).
        *   `Максимальный коэффициент вариции (%):` Насколько целевое значение может колебаться для ML-прогноза (по умолчанию 30%).
        *   `Минимальное количество дней активности:` Общая продолжительность истории событий (по умолчанию 365 дней).
    *   **Сегменты:**
        *   `Подходит для прогнозирования:` Достаточно данных, умеренная волатильность, достаточная история. **Подходят для:** Сложных моделей (ARIMA, Prophet, LSTM). **Пример:** "TS-STEEL-SHEET" - 100 записей за 2 года, CV=15%.
        *   `Нестабильный (Высокая волатильность):` Значение изменяется слишком сильно и непредсказуемо. **Прогноз затруднен**, требует экспертной оценки или других подходов. **Пример:** "TS-STOCK-TECHCORP" - 25 записей, CV=70%.
        *   `Недостаточно данных:` Слишком мало записей для надежного прогноза. **Прогноз не рекомендуется**. **Пример:** "TS-ALLOY-Z" - 3 записи за 1 месяц.
        *   `Недостаточно активный:` Короткая история не позволяет выявить тренды. **Подходят для:** Простых моделей (среднее, последняя цена). **Пример:** "TS-COMPONENT-Y" - 50 записей за 1 год.
        *   `Неактивные:` Событий не было дольше установленного порога. **Прогноз невозможен** без новых данных. **Пример:** "TS-LAMP-60W" - последнее событие 2 года назад.

    #### 9. Анализ безопасности
    *   Выявляет подозрительные паттерны во временных рядах, которые могут указывать на риски (мошенничество, ошибки).
    *   **Анализируемые индикаторы:**
        *   Высокая волатильность целевых значений (резкие скачки).
        *   Признаки дробления событий (много мелких событий ниже порогов).
        *   Повышенная активность в конце отчетных периодов (месяц, квартал).
        *   Подозрительно округленные значения (например, 10000.00 вместо 9985.50).
        *   Аномальная стабильность для рядов, которые должны быть волатильными.
    *   Временные ряды ранжируются по уровню риска (Низкий, Средний, Высокий).
    *   Для временных рядов с высоким риском доступен **детальный анализ** с графиками и таблицами аномалий.
    *   **Пример:** Обнаружено, что события для ряда "TS-CABLE-COPPER" часто происходят с целевым значением, близким к 49900 (при пороге в 50000) в последние дни квартала.

    #### 10. Экспорт данных
    *   Позволяет выгрузить результаты анализа и сегментации для использования в других системах или для отчетности.
    *   **Опции экспорта:**
        *   `Экспорт по сегментам:` Скачать данные для одного выбранного сегмента (например, только 'Подходит для прогнозирования') в CSV или Excel.
        *   `Массовый экспорт:` Скачать данные для всех сегментов одним ZIP-архивом, где каждый сегмент - отдельный файл.
        *   `Настраиваемый экспорт:` (Может быть добавлено в будущем) - Экспорт с дополнительными фильтрами.
    *   **Пример:** Экспортировать список временных рядов из сегмента 'Подходит для прогнозирования' в Excel для передачи в систему прогнозирования.

    ### Советы по использованию

    1.  **Качество данных:** Успех анализа сильно зависит от качества исходных данных. Убедитесь, что файл содержит корректные данные, особенно для колонок, сопоставленных ролям `ID`, `Дата` и `Целевая колонка`.
    2.  **Параметры сегментации:** Подбирайте параметры сегментации в разделе 8 в соответствии с вашими целями прогнозирования и особенностями данных. Экспериментируйте с порогами.
    3.  **Большие объемы:** При работе с очень большими файлами (сотни тысяч строк) анализ и сегментация могут занять время. Анализ безопасности для большого числа временных рядов с высоким риском также может быть долгим. Используйте фильтры или выбирайте ограниченное количество рядов для детального анализа.
    4.  **Интерпретация:** Не все временные ряды в сегменте 'Высокая волатильность' или с высоким риском безопасности обязательно являются проблемными. Это лишь индикаторы, требующие дополнительного изучения.
    5.  **Анализ безопасности:** Используйте детальный анализ для временных рядов с высоким риском, чтобы понять конкретные причины аномалий (скачки значений, дробление и т.д.).

    """, unsafe_allow_html=False) # Используем Markdown, HTML не разрешен

def show_performance_info():
    """
    Отображает информацию о производительности приложения
    """
    try:
        import psutil
        import gc
        
        # Запускаем сборку мусора
        gc.collect()
        
        # Получаем информацию о текущем процессе
        process = psutil.Process()
        
        # Получаем информацию о памяти
        memory_info = process.memory_info()
        memory_usage_mb = memory_info.rss / 1024 / 1024  # в МБ
        
        # Получаем информацию о CPU
        cpu_percent = process.cpu_percent(interval=0.1)
        
        # Получаем информацию о системе
        system_memory = psutil.virtual_memory()
        system_memory_usage_percent = system_memory.percent
        system_cpu_percent = psutil.cpu_percent(interval=0.1) # Общая загрузка CPU системы
        
        # Создаем HTML для вывода информации
        performance_html = f"""
        <div style="background-color: #E8F5E9; padding: 10px; border-radius: 5px; margin: 10px 0; font-size: 0.8em;">
            <h4 style="color: #2E7D32; margin-top: 0; margin-bottom: 5px;">Информация о производительности</h4>
            <p style="margin: 2px 0;"><strong>Использование памяти:</strong> {memory_usage_mb:.1f} МБ ({(memory_usage_mb/system_memory.total*100):.1f}% от доступной)</p>
            <p style="margin: 2px 0;"><strong>Загрузка CPU (приложение):</strong> {cpu_percent:.1f}%</p>
            <p style="margin: 2px 0;"><strong>Загрузка CPU (система):</strong> {system_cpu_percent:.1f}%</p>
            <p style="margin: 2px 0;"><strong>Загрузка памяти системы:</strong> {system_memory_usage_percent:.1f}%</p>
            <p style="margin: 2px 0;"><strong>Доступно памяти:</strong> {(system_memory.available/1024/1024):.1f} МБ</p>
        </div>
        """
        
        st.sidebar.markdown(performance_html, unsafe_allow_html=True)
    except ImportError:
        # Если psutil не установлен, просто пропускаем вывод информации
        pass
    except Exception as e:
        # Если произошла ошибка, выводим ее в консоль, но не в интерфейс
        print(f"Ошибка при получении информации о производительности: {str(e)}")

def show_app_version():
    """
    Отображает информацию о версии приложения
    """
    version_html = """
    <div style="text-align: center; margin-top: 20px; font-size: 0.8em; color: #757575;">
        <p>Версия 1.1.0 | Обновлено: 10.04.2025</p>
    <p>© 2025 Анализ и прогнозирование временных рядов</p>
    </div>
    """
    
    st.sidebar.markdown(version_html, unsafe_allow_html=True)